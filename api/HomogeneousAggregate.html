<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HomogeneousAggregate S &mdash; FriCAS 1.3.2 API</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FriCAS 1.3.2 API" href="index.html" />
    <link rel="up" title="Categories" href="Categories.html" />
    <link rel="next" title="HopfAlgebra(R, MxM)" href="HopfAlgebra.html" />
    <link rel="prev" title="Group" href="Group.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="HopfAlgebra.html" title="HopfAlgebra(R, MxM)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Group.html" title="Group"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">FriCAS 1.3.2 API</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="Categories.html" accesskey="U">Categories</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="homogeneousaggregate-s">
<span id="l-homogeneous-aggregate"></span><span id="index-0"></span><h1>HomogeneousAggregate S<a class="headerlink" href="#homogeneousaggregate-s" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference external" href="https://github.com/hemmecke/fricas/blob/master-hemmecke/src/algebra/aggcat.spad#L56">aggcat.spad line 56</a></p>
<ul class="simple">
<li>S: <a class="reference internal" href="Type.html#l-type"><span>Type</span></a></li>
</ul>
<p>A homogeneous aggregate is an aggregate of elements all of the same type. In the current system, all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a> have a finite number of members. Of course, such a domain may have an infinite number of elements, like, for example <a class="reference internal" href="List.html#l-list"><span>List</span></a>. Those domains with attribute <a class="reference internal" href="shallowlyMutable.html#l-shallowly-mutable"><span>shallowlyMutable</span></a> allow an element to be modified or updated without changing its overall value.</p>
<dl class="docutils">
<dt><a class="reference internal" href="Aggregate.html#id1"><span>#</span></a>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span>NonNegativeInteger</span></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
<dt><a class="reference internal" href="BasicType.html#id1"><span>=</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a> or S has <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd>from <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a></dd>
<dt><a class="reference internal" href="BasicType.html#id2"><span>~=</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a> or S has <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd>from <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-any"></span><dl class="docutils" id="index-1">
<dt><span class="spadfun">any?</span>: (S -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a>, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">any?(p,</span> <span class="pre">u)</span></code> tests if <code class="docutils literal"><span class="pre">p(x)</span></code> is <code class="docutils literal"><span class="pre">true</span></code> for any element <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">u</span></code>. Note: for collections, <code class="docutils literal"><span class="pre">any?(p,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(or,</span> <span class="pre">map(p,</span> <span class="pre">u),</span> <span class="pre">false,</span> <span class="pre">true)</span></code>. However, <code class="docutils literal"><span class="pre">any?(p,</span> <span class="pre">u)</span></code> returns as soon as it finds an element for which <code class="docutils literal"><span class="pre">p</span></code> gives <code class="docutils literal"><span class="pre">true</span></code>.</dd>
<dt><a class="reference internal" href="CoercibleTo.html#l-coercible-to-coerce"><span>coerce</span></a>: % -&gt; <a class="reference internal" href="OutputForm.html#l-output-form"><span>OutputForm</span></a> if S has <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span>CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l-output-form"><span>OutputForm</span></a></dt>
<dd>from <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span>CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l-output-form"><span>OutputForm</span></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-copy"><span>copy</span></a>: % -&gt; %</dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-count"></span><dl class="docutils" id="index-2">
<dt><span class="spadfun">count</span>: (S -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a>, %) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span>NonNegativeInteger</span></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">count(p,</span> <span class="pre">u)</span></code> returns the number of elements <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">u</span></code> such that <code class="docutils literal"><span class="pre">p(x)</span></code> is <code class="docutils literal"><span class="pre">true</span></code>. For collections, <code class="docutils literal"><span class="pre">count(p,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(+,</span> <span class="pre">[1</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">u</span> <span class="pre">|</span> <span class="pre">p(x)],</span> <span class="pre">0)</span></code>.</dd>
</dl>
<dl class="docutils" id="index-3">
<dt><span class="spadfun">count</span>: (S, %) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span>NonNegativeInteger</span></a> if S has <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">count(x,</span> <span class="pre">u)</span></code> returns the number of occurrences of <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">u</span></code>. For collections, <code class="docutils literal"><span class="pre">count(x,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(+,</span> <span class="pre">[1</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">u</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y],</span> <span class="pre">0)</span></code>.</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-empty"><span>empty</span></a>: () -&gt; %</dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
<dt><a class="reference internal" href="Aggregate.html#id2"><span>empty?</span></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-eq"><span>eq?</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
<dt><a class="reference internal" href="Evalable.html#l-evalable-eval"><span>eval</span></a>: (%, <a class="reference internal" href="Equation.html#l-equation"><span>Equation</span></a> S) -&gt; % if S has <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S and S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S</dd>
<dt><a class="reference internal" href="Evalable.html#l-evalable-eval"><span>eval</span></a>: (%, <a class="reference internal" href="List.html#l-list"><span>List</span></a> <a class="reference internal" href="Equation.html#l-equation"><span>Equation</span></a> S) -&gt; % if S has <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S and S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S</dd>
<dt><a class="reference internal" href="InnerEvalable.html#l-inner-evalable-eval"><span>eval</span></a>: (%, <a class="reference internal" href="List.html#l-list"><span>List</span></a> S, <a class="reference internal" href="List.html#l-list"><span>List</span></a> S) -&gt; % if S has <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S and S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><span>InnerEvalable</span></a>(S, S)</dd>
<dt><a class="reference internal" href="InnerEvalable.html#l-inner-evalable-eval"><span>eval</span></a>: (%, S, S) -&gt; % if S has <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S and S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><span>InnerEvalable</span></a>(S, S)</dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-every"></span><dl class="docutils" id="index-4">
<dt><span class="spadfun">every?</span>: (S -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a>, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">every?(p,</span> <span class="pre">u)</span></code> tests if <code class="docutils literal"><span class="pre">p</span></code>(<code class="docutils literal"><span class="pre">x</span></code>) is <code class="docutils literal"><span class="pre">true</span></code> for all elements <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">u</span></code>. Note: for collections, <code class="docutils literal"><span class="pre">every?(p,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(and,</span> <span class="pre">map(p,</span> <span class="pre">u),</span> <span class="pre">true,</span> <span class="pre">false)</span></code>. However, <code class="docutils literal"><span class="pre">every?(p,</span> <span class="pre">u)</span></code> returns as soon as it finds an element for which <code class="docutils literal"><span class="pre">p</span></code> gives <code class="docutils literal"><span class="pre">false</span></code>.</dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-hash"><span>hash</span></a>: % -&gt; <a class="reference internal" href="SingleInteger.html#l-single-integer"><span>SingleInteger</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-hash-update"><span>hashUpdate!</span></a>: (<a class="reference internal" href="HashState.html#l-hash-state"><span>HashState</span></a>, %) -&gt; <a class="reference internal" href="HashState.html#l-hash-state"><span>HashState</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-latex"><span>latex</span></a>: % -&gt; <a class="reference internal" href="String.html#l-string"><span>String</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dt>
<dd>from <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-less"><span>less?</span></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span>NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-map"></span><dl class="docutils" id="index-5">
<dt><span class="spadfun">map!</span>: (S -&gt; S, %) -&gt; % if % has <a class="reference internal" href="shallowlyMutable.html#l-shallowly-mutable"><span>shallowlyMutable</span></a></dt>
<dd><code class="docutils literal"><span class="pre">map!(f,</span> <span class="pre">u)</span></code> destructively replaces each element <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">u</span></code> by <code class="docutils literal"><span class="pre">f(x)</span></code>.</dd>
</dl>
<span class="target" id="id1"></span><dl class="docutils" id="index-6">
<dt><span class="spadfun">map</span>: (S -&gt; S, %) -&gt; %</dt>
<dd><code class="docutils literal"><span class="pre">map(f,</span> <span class="pre">u)</span></code> returns a copy of <code class="docutils literal"><span class="pre">u</span></code> with each element <code class="docutils literal"><span class="pre">x</span></code> replaced by <code class="docutils literal"><span class="pre">f</span></code>(<code class="docutils literal"><span class="pre">x</span></code>). For collections, <code class="docutils literal"><span class="pre">map(f,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">[f(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">u]</span></code>.</dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-member"></span><dl class="docutils" id="index-7">
<dt><span class="spadfun">member?</span>: (S, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a> if S has <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">member?(x,</span> <span class="pre">u)</span></code> tests if <code class="docutils literal"><span class="pre">x</span></code> is a member of <code class="docutils literal"><span class="pre">u</span></code>. For collections, <code class="docutils literal"><span class="pre">member?(x,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(or,</span> <span class="pre">[x=y</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">u],</span> <span class="pre">false)</span></code>. However, <code class="docutils literal"><span class="pre">member?(x,</span> <span class="pre">u)</span></code> returns as soon as it finds a member.</dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-members"></span><dl class="docutils" id="index-8">
<dt><span class="spadfun">members</span>: % -&gt; <a class="reference internal" href="List.html#l-list"><span>List</span></a> S if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">members(u)</span></code> returns a list of the consecutive elements of <code class="docutils literal"><span class="pre">u</span></code>. For multisets <span class="spadfun">members</span> gives result with no repetition. See also <span class="spadfun">parts</span>.</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-more"><span>more?</span></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span>NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-parts"></span><dl class="docutils" id="index-9">
<dt><span class="spadfun">parts</span>: % -&gt; <a class="reference internal" href="List.html#l-list"><span>List</span></a> S if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></dt>
<dd><code class="docutils literal"><span class="pre">parts(u)</span></code> returns a list of the consecutive elements of <code class="docutils literal"><span class="pre">u</span></code>. For finite collections, <code class="docutils literal"><span class="pre">construct(parts(u))</span> <span class="pre">=</span> <span class="pre">u</span></code>.</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-sample"><span>sample</span></a>: %</dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-size"><span>size?</span></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span>NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span>Boolean</span></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></dd>
</dl>
<p><a class="reference internal" href="Aggregate.html#l-aggregate"><span>Aggregate</span></a></p>
<p><a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a> or S has <a class="reference internal" href="BasicType.html#l-basic-type"><span>BasicType</span></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span>finiteAggregate</span></a></p>
<p><a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span>CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l-output-form"><span>OutputForm</span></a> if S has <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span>CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l-output-form"><span>OutputForm</span></a></p>
<p><a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S if S has <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S and S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></p>
<p><a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><span>InnerEvalable</span></a>(S, S) if S has <a class="reference internal" href="Evalable.html#l-evalable"><span>Evalable</span></a> S and S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></p>
<p><a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><span>SetCategory</span></a></p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Categories.html">Categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="Domains.html">Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="Packages.html">Packages</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="HopfAlgebra.html" title="HopfAlgebra(R, MxM)"
             >next</a> |</li>
        <li class="right" >
          <a href="Group.html" title="Group"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">FriCAS 1.3.2 API</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="Categories.html" >Categories</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014-2017, FriCAS Team.
    </div>
  </body>
</html>