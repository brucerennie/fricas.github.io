<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HomogeneousAggregate S &mdash; FriCAS 1.2.3 API</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FriCAS 1.2.3 API" href="../index.html" />
    <link rel="up" title="Categories" href="Categories.html" />
    <link rel="next" title="HopfAlgebra(R, MxM)" href="HopfAlgebra.html" />
    <link rel="prev" title="Group" href="Group.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="HopfAlgebra.html" title="HopfAlgebra(R, MxM)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Group.html" title="Group"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">FriCAS 1.2.3 API</a> &raquo;</li>
          <li><a href="index.html" >FriCAS</a> &raquo;</li>
          <li><a href="Categories.html" accesskey="U">Categories</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="homogeneousaggregate-s">
<span id="l-homogeneous-aggregate"></span><span id="index-0"></span><h1>HomogeneousAggregate S<a class="headerlink" href="#homogeneousaggregate-s" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference external" href="https://github.com/fricas/fricas/blob/master/src/algebra//aggcat.spad#L55">aggcat.spad line 55</a></p>
<ul class="simple">
<li>S: <a class="reference internal" href="Type.html#l-type"><em>Type</em></a></li>
</ul>
<p>A homogeneous aggregate is an aggregate of elements all of the same type. In the current system, all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a> have a finite number of members. Of course, such a domain may have an infinite number of elements, like, for example <a class="reference internal" href="List.html#l-list"><em>List</em></a>. Those domains with attribute <a class="reference internal" href="shallowlyMutable.html#l-shallowly-mutable"><em>shallowlyMutable</em></a> allow an element to be modified or updated without changing its overall value.</p>
<dl class="docutils">
<dt><a class="reference internal" href="Aggregate.html#id1"><em>#</em></a>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><em>NonNegativeInteger</em></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
<dt><a class="reference internal" href="BasicType.html#id1"><em>=</em></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a> if S has <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a> or S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dt>
<dd>from <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a></dd>
<dt><a class="reference internal" href="BasicType.html#id2"><em>~=</em></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a> if S has <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a> or S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dt>
<dd>from <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-any"></span><dl class="docutils" id="index-1">
<dt><span class="spadfun">any?</span>: (S -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">any?(p,</span> <span class="pre">u)</span></tt> tests if <tt class="docutils literal"><span class="pre">p(x)</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> for any element <tt class="docutils literal"><span class="pre">x</span></tt> of <tt class="docutils literal"><span class="pre">u</span></tt>. Note: for collections, <tt class="docutils literal"><span class="pre">any?(p,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(or,</span> <span class="pre">map(f,</span> <span class="pre">u),</span> <span class="pre">false,</span> <span class="pre">true)</span></tt>. However, <tt class="docutils literal"><span class="pre">any?(p,</span> <span class="pre">u)</span></tt> returns as soon as it finds an element for which <tt class="docutils literal"><span class="pre">p</span></tt> gives <tt class="docutils literal"><span class="pre">true</span></tt>.</dd>
<dt><a class="reference internal" href="CoercibleTo.html#l-coercible-to-coerce"><em>coerce</em></a>: % -&gt; <a class="reference internal" href="OutputForm.html#l-output-form"><em>OutputForm</em></a> if S has <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><em>CoercibleTo</em></a> <a class="reference internal" href="OutputForm.html#l-output-form"><em>OutputForm</em></a></dt>
<dd>from <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><em>CoercibleTo</em></a> <a class="reference internal" href="OutputForm.html#l-output-form"><em>OutputForm</em></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-copy"><em>copy</em></a>: % -&gt; %</dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-count"></span><dl class="docutils" id="index-2">
<dt><span class="spadfun">count</span>: (S -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, %) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><em>NonNegativeInteger</em></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">count(p,</span> <span class="pre">u)</span></tt> returns the number of elements <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">u</span></tt> such that <tt class="docutils literal"><span class="pre">p(x)</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>. For collections, <tt class="docutils literal"><span class="pre">count(p,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(+,</span> <span class="pre">[1</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">u</span> <span class="pre">|</span> <span class="pre">p(x)],</span> <span class="pre">0)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-3">
<dt><span class="spadfun">count</span>: (S, %) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><em>NonNegativeInteger</em></a> if S has <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">count(x,</span> <span class="pre">u)</span></tt> returns the number of occurrences of <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">u</span></tt>. For collections, <tt class="docutils literal"><span class="pre">count(x,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(+,</span> <span class="pre">[x=y</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">u],</span> <span class="pre">0)</span></tt>.</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-empty"><em>empty</em></a>: () -&gt; %</dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
<dt><a class="reference internal" href="Aggregate.html#id2"><em>empty?</em></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-eq"><em>eq?</em></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
<dt><a class="reference internal" href="Evalable.html#l-evalable-eval"><em>eval</em></a>: (%, <a class="reference internal" href="Equation.html#l-equation"><em>Equation</em></a> S) -&gt; % if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> and S has <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</dt>
<dd>from <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</dd>
<dt><a class="reference internal" href="Evalable.html#l-evalable-eval"><em>eval</em></a>: (%, <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Equation.html#l-equation"><em>Equation</em></a> S) -&gt; % if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> and S has <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</dt>
<dd>from <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</dd>
<dt><a class="reference internal" href="InnerEvalable.html#l-inner-evalable-eval"><em>eval</em></a>: (%, <a class="reference internal" href="List.html#l-list"><em>List</em></a> S, <a class="reference internal" href="List.html#l-list"><em>List</em></a> S) -&gt; % if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> and S has <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</dt>
<dd>from <a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><em>InnerEvalable</em></a>(S, S)</dd>
<dt><a class="reference internal" href="InnerEvalable.html#l-inner-evalable-eval"><em>eval</em></a>: (%, S, S) -&gt; % if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> and S has <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</dt>
<dd>from <a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><em>InnerEvalable</em></a>(S, S)</dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-every"></span><dl class="docutils" id="index-4">
<dt><span class="spadfun">every?</span>: (S -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a> if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">every?(f,</span> <span class="pre">u)</span></tt> tests if <tt class="docutils literal"><span class="pre">p</span></tt>(<tt class="docutils literal"><span class="pre">x</span></tt>) is <tt class="docutils literal"><span class="pre">true</span></tt> for all elements <tt class="docutils literal"><span class="pre">x</span></tt> of <tt class="docutils literal"><span class="pre">u</span></tt>. Note: for collections, <tt class="docutils literal"><span class="pre">every?(p,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(and,</span> <span class="pre">map(f,</span> <span class="pre">u),</span> <span class="pre">true,</span> <span class="pre">false)</span></tt>. However, <tt class="docutils literal"><span class="pre">every?(p,</span> <span class="pre">u)</span></tt> returns as soon as it finds an element for which <tt class="docutils literal"><span class="pre">p</span></tt> gives <tt class="docutils literal"><span class="pre">false</span></tt>.</dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-hash"><em>hash</em></a>: % -&gt; <a class="reference internal" href="SingleInteger.html#l-single-integer"><em>SingleInteger</em></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dt>
<dd>from <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-hash-update"><em>hashUpdate!</em></a>: (<a class="reference internal" href="HashState.html#l-hash-state"><em>HashState</em></a>, %) -&gt; <a class="reference internal" href="HashState.html#l-hash-state"><em>HashState</em></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dt>
<dd>from <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-latex"><em>latex</em></a>: % -&gt; <a class="reference internal" href="String.html#l-string"><em>String</em></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dt>
<dd>from <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-less"><em>less?</em></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><em>NonNegativeInteger</em></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-map"></span><dl class="docutils" id="index-5">
<dt><span class="spadfun">map!</span>: (S -&gt; S, %) -&gt; % if % has <a class="reference internal" href="shallowlyMutable.html#l-shallowly-mutable"><em>shallowlyMutable</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">map!(f,</span> <span class="pre">u)</span></tt> destructively replaces each element <tt class="docutils literal"><span class="pre">x</span></tt> of <tt class="docutils literal"><span class="pre">u</span></tt> by <tt class="docutils literal"><span class="pre">f(x)</span></tt>.</dd>
</dl>
<span class="target" id="id1"></span><dl class="docutils" id="index-6">
<dt><span class="spadfun">map</span>: (S -&gt; S, %) -&gt; %</dt>
<dd><tt class="docutils literal"><span class="pre">map(f,</span> <span class="pre">u)</span></tt> returns a copy of <tt class="docutils literal"><span class="pre">u</span></tt> with each element <tt class="docutils literal"><span class="pre">x</span></tt> replaced by <tt class="docutils literal"><span class="pre">f</span></tt>(<tt class="docutils literal"><span class="pre">x</span></tt>). For collections, <tt class="docutils literal"><span class="pre">map(f,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">[f(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">u]</span></tt>.</dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-member"></span><dl class="docutils" id="index-7">
<dt><span class="spadfun">member?</span>: (S, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a> if S has <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">member?(x,</span> <span class="pre">u)</span></tt> tests if <tt class="docutils literal"><span class="pre">x</span></tt> is a member of <tt class="docutils literal"><span class="pre">u</span></tt>. For collections, <tt class="docutils literal"><span class="pre">member?(x,</span> <span class="pre">u)</span> <span class="pre">=</span> <span class="pre">reduce(or,</span> <span class="pre">[x=y</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">u],</span> <span class="pre">false)</span></tt>. However, <tt class="docutils literal"><span class="pre">member?(x,</span> <span class="pre">u)</span></tt> returns as soon as it finds a member.</dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-members"></span><dl class="docutils" id="index-8">
<dt><span class="spadfun">members</span>: % -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> S if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">members(u)</span></tt> returns a list of the consecutive elements of <tt class="docutils literal"><span class="pre">u</span></tt>. For collections, <tt class="docutils literal"><span class="pre">parts([x,</span> <span class="pre">y,</span> <span class="pre">...,</span> <span class="pre">z])</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">...,</span> <span class="pre">z)</span></tt>.</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-more"><em>more?</em></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><em>NonNegativeInteger</em></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
</dl>
<span class="target" id="l-homogeneous-aggregate-parts"></span><dl class="docutils" id="index-9">
<dt><span class="spadfun">parts</span>: % -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> S if % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">parts(u)</span></tt> returns a list of the consecutive elements of <tt class="docutils literal"><span class="pre">u</span></tt>. For collections, <tt class="docutils literal"><span class="pre">parts([x,</span> <span class="pre">y,</span> <span class="pre">...,</span> <span class="pre">z])</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">...,</span> <span class="pre">z)</span></tt>.</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-sample"><em>sample</em></a>: %</dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-size"><em>size?</em></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><em>NonNegativeInteger</em></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a></dt>
<dd>from <a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></dd>
</dl>
<p><a class="reference internal" href="Aggregate.html#l-aggregate"><em>Aggregate</em></a></p>
<p><a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> or S has <a class="reference internal" href="BasicType.html#l-basic-type"><em>BasicType</em></a> and % has <a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><em>finiteAggregate</em></a></p>
<p><a class="reference internal" href="CoercibleTo.html#l-coercible-to"><em>CoercibleTo</em></a> <a class="reference internal" href="OutputForm.html#l-output-form"><em>OutputForm</em></a> if S has <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><em>CoercibleTo</em></a> <a class="reference internal" href="OutputForm.html#l-output-form"><em>OutputForm</em></a></p>
<p><a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> and S has <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</p>
<p><a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><em>InnerEvalable</em></a>(S, S) if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> and S has <a class="reference internal" href="Evalable.html#l-evalable"><em>Evalable</em></a> S</p>
<p><a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a> if S has <a class="reference internal" href="SetCategory.html#l-set-category"><em>SetCategory</em></a></p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FriCAS</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="Categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="Domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="Packages.html">Packages</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/HomogeneousAggregate.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="HopfAlgebra.html" title="HopfAlgebra(R, MxM)"
             >next</a> |</li>
        <li class="right" >
          <a href="Group.html" title="Group"
             >previous</a> |</li>
        <li><a href="../index.html">FriCAS 1.2.3 API</a> &raquo;</li>
          <li><a href="index.html" >FriCAS</a> &raquo;</li>
          <li><a href="Categories.html" >Categories</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, FriCAS Team.
      Last updated on Jul 20, 2014.
    </div>
  </body>
</html>